// Generated by Apple Swift version 4.2 (swiftlang-1000.11.37.1 clang-1000.11.45.1)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import CoreGraphics;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="Parchment",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class UIScrollView;
@class NSBundle;
@class NSCoder;

/// Manages page navigation between view controllers. View controllers can be navigated via swiping gestures, or called programmatically.
SWIFT_CLASS("_TtC9Parchment20EMPageViewController")
@interface EMPageViewController : UIViewController <UIScrollViewDelegate>
/// Transitions to the view controller right of the currently selected view controller in a horizontal orientation, or below the currently selected view controller in a vertical orientation. Also described as going to the next page.
/// \param animated A Boolean whether or not to animate the transition
///
/// \param completion A block that’s called after the transition is finished. The block parameter <code>transitionSuccessful</code> is <code>true</code> if the transition to the selected view controller was completed successfully. If <code>false</code>, the transition returned to the view controller it started from.
///
- (void)scrollForwardAnimated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
/// Transitions to the view controller left of the currently selected view controller in a horizontal orientation, or above the currently selected view controller in a vertical orientation. Also described as going to the previous page.
/// \param animated A Boolean whether or not to animate the transition
///
/// \param completion A block that’s called after the transition is finished. The block parameter <code>transitionSuccessful</code> is <code>true</code> if the transition to the selected view controller was completed successfully. If <code>false</code>, the transition returned to the view controller it started from.
///
- (void)scrollReverseAnimated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
@property (nonatomic, readonly) BOOL shouldAutomaticallyForwardAppearanceMethods;
- (void)viewDidLoad;
- (void)viewWillLayoutSubviews;
- (void)scrollViewDidScroll:(UIScrollView * _Nonnull)scrollView;
- (void)scrollViewWillBeginDragging:(UIScrollView * _Nonnull)scrollView;
- (void)scrollViewDidEndDecelerating:(UIScrollView * _Nonnull)scrollView;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


/// The <code>EMPageViewControllerDataSource</code> protocol is adopted to provide the view controllers that are displayed when the user scrolls through pages. Methods are called on an as-needed basis.
/// Each method returns a <code>UIViewController</code> object or <code>nil</code> if there are no view controllers to be displayed.
/// note:
/// If the data source is <code>nil</code>, gesture based scrolling will be disabled and all view controllers must be provided through <code>selectViewController:direction:animated:completion:</code>.
SWIFT_PROTOCOL("_TtP9Parchment30EMPageViewControllerDataSource_")
@protocol EMPageViewControllerDataSource
/// Called to optionally return a view controller that is to the left of a given view controller in a horizontal orientation, or above a given view controller in a vertical orientation.
/// \param pageViewController The page view controller
///
/// \param viewController The point of reference view controller
///
///
/// returns:
/// The view controller that is to the left of the given <code>viewController</code> in a horizontal orientation, or above the given <code>viewController</code> in a vertical orientation, or <code>nil</code> if there is no view controller to be displayed.
- (UIViewController * _Nullable)em_pageViewController:(EMPageViewController * _Nonnull)pageViewController viewControllerBeforeViewController:(UIViewController * _Nonnull)viewController SWIFT_WARN_UNUSED_RESULT;
/// Called to optionally return a view controller that is to the right of a given view controller.
/// \param pageViewController The page view controller
///
/// \param viewController The point of reference view controller
///
///
/// returns:
/// The view controller that is to the right of the given <code>viewController</code> in a horizontal orientation, or below the given <code>viewController</code> in a vertical orientation, or <code>nil</code> if there is no view controller to be displayed.
- (UIViewController * _Nullable)em_pageViewController:(EMPageViewController * _Nonnull)pageViewController viewControllerAfterViewController:(UIViewController * _Nonnull)viewController SWIFT_WARN_UNUSED_RESULT;
@end


/// The EMPageViewControllerDelegate protocol is adopted to receive messages for all important events of the page transition process.
SWIFT_PROTOCOL("_TtP9Parchment28EMPageViewControllerDelegate_")
@protocol EMPageViewControllerDelegate
@optional
/// Called before scrolling to a new view controller.
/// note:
/// This method will not be called if the starting view controller is <code>nil</code>. A common scenario where this will occur is when you initialize the page view controller and use <code>selectViewController:direction:animated:completion:</code> to load the first selected view controller.
/// important:
/// If bouncing is enabled, it is possible this method will be called more than once for one page transition. It can be called before the initial scroll to the destination view controller (which is when it is usually called), and it can also be called when the scroll momentum carries over slightly to the view controller after the original destination view controller.
/// \param pageViewController The page view controller
///
/// \param startingViewController The currently selected view controller the transition is starting from
///
/// \param destinationViewController The view controller that will be scrolled to, where the transition should end
///
- (void)em_pageViewController:(EMPageViewController * _Nonnull)pageViewController willStartScrollingFrom:(UIViewController * _Nonnull)startingViewController destinationViewController:(UIViewController * _Nonnull)destinationViewController;
/// Called whenever there has been a scroll position change in a page transition. This method is very useful if you need to know the exact progress of the page transition animation.
/// note:
/// This method will not be called if the starting view controller is <code>nil</code>. A common scenario where this will occur is when you initialize the page view controller and use <code>selectViewController:direction:animated:completion:</code> to load the first selected view controller.
/// \param pageViewController The page view controller
///
/// \param startingViewController The currently selected view controller the transition is starting from
///
/// \param destinationViewController The view controller being scrolled to where the transition should end
///
/// \param progress The progress of the transition, where 0 is a neutral scroll position, >= 1 is a complete transition to the right view controller in a horizontal orientation, or the below view controller in a vertical orientation, and <= -1 is a complete transition to the left view controller in a horizontal orientation, or the above view controller in a vertical orientation. Values may be greater than 1 or less than -1 if bouncing is enabled and the scroll velocity is quick enough.
///
- (void)em_pageViewController:(EMPageViewController * _Nonnull)pageViewController isScrollingFrom:(UIViewController * _Nonnull)startingViewController destinationViewController:(UIViewController * _Nullable)destinationViewController progress:(CGFloat)progress;
/// Called after a page transition attempt has completed.
/// important:
/// If bouncing is enabled, it is possible this method will be called more than once for one page transition. It can be called after the scroll transition to the intended destination view controller (which is when it is usually called), and it can also be called when the scroll momentum carries over slightly to the view controller after the intended destination view controller. In the latter scenario, <code>transitionSuccessful</code> will return <code>false</code> the second time it’s called because the scroll view will bounce back to the intended destination view controller.
/// \param pageViewController The page view controller
///
/// \param startingViewController The currently selected view controller the transition is starting from
///
/// \param destinationViewController The view controller that has been attempted to be selected
///
/// \param transitionSuccessful A Boolean whether the transition to the destination view controller was successful or not. If <code>true</code>, the new selected view controller is <code>destinationViewController</code>. If <code>false</code>, the transition returned to the view controller it started from, so the selected view controller is still <code>startingViewController</code>.
///
- (void)em_pageViewController:(EMPageViewController * _Nonnull)pageViewController didFinishScrollingFrom:(UIViewController * _Nullable)startingViewController destinationViewController:(UIViewController * _Nonnull)destinationViewController transitionSuccessful:(BOOL)transitionSuccessful;
@end

/// The navigation scroll direction.
typedef SWIFT_ENUM(NSInteger, EMPageViewControllerNavigationDirection, closed) {
/// Forward direction. Can be right in a horizontal orientation or down in a vertical orientation.
  EMPageViewControllerNavigationDirectionForward = 0,
/// Reverse direction. Can be left in a horizontal orientation or up in a vertical orientation.
  EMPageViewControllerNavigationDirectionReverse = 1,
};

/// The navigation scroll orientation.
typedef SWIFT_ENUM(NSInteger, EMPageViewControllerNavigationOrientation, closed) {
/// Horiziontal orientation. Scrolls left and right.
  EMPageViewControllerNavigationOrientationHorizontal = 0,
/// Vertical orientation. Scrolls up and down.
  EMPageViewControllerNavigationOrientationVertical = 1,
};


SWIFT_CLASS("_TtC9Parchment28PagingBorderLayoutAttributes")
@interface PagingBorderLayoutAttributes : UICollectionViewLayoutAttributes
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A custom <code>UICollectionViewReusableView</code> subclass used to display
/// the border at the bottom of the menu items. You can subclass this
/// type if you need further customization; just override the
/// <code>borderClass</code> property in <code>PagingViewController</code>.
SWIFT_CLASS("_TtC9Parchment16PagingBorderView")
@interface PagingBorderView : UICollectionReusableView
- (void)applyLayoutAttributes:(UICollectionViewLayoutAttributes * _Nonnull)layoutAttributes;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


/// A custom <code>UICollectionViewCell</code> subclass used to display the menu
/// items. When creating your own custom cells, you need to subclass
/// this type instead of <code>UICollectionViewCell</code> directly.
SWIFT_CLASS("_TtC9Parchment10PagingCell")
@interface PagingCell : UICollectionViewCell
- (UICollectionViewLayoutAttributes * _Nonnull)preferredLayoutAttributesFittingAttributes:(UICollectionViewLayoutAttributes * _Nonnull)layoutAttributes SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


/// A custom <code>UICollectionViewLayoutAttributes</code> subclass that adds a
/// <code>progress</code> property indicating how far the user has scrolled.
SWIFT_CLASS("_TtC9Parchment26PagingCellLayoutAttributes")
@interface PagingCellLayoutAttributes : UICollectionViewLayoutAttributes
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC9Parchment31PagingIndicatorLayoutAttributes")
@interface PagingIndicatorLayoutAttributes : UICollectionViewLayoutAttributes
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A custom <code>UICollectionViewReusableView</code> subclass used to display a
/// view that indicates the currently selected cell. You can subclass
/// this type if you need further customization; just override the
/// <code>indicatorClass</code> property in <code>PagingViewController</code>.
SWIFT_CLASS("_TtC9Parchment19PagingIndicatorView")
@interface PagingIndicatorView : UICollectionReusableView
- (void)applyLayoutAttributes:(UICollectionViewLayoutAttributes * _Nonnull)layoutAttributes;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC9Parchment25PagingInvalidationContext")
@interface PagingInvalidationContext : UICollectionViewLayoutInvalidationContext
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A custom <code>PagingCell</code> implementation that only displays a text
/// label. The title is based on the <code>PagingTitleItem</code> and the colors
/// are based on the <code>PagingTheme</code> passed into <code>setPagingItem:</code>. When
/// applying layout attributes it will interpolate between the default
/// and selected text color based on the <code>progress</code> property.
SWIFT_CLASS("_TtC9Parchment15PagingTitleCell")
@interface PagingTitleCell : PagingCell
@property (nonatomic, getter=isSelected) BOOL selected;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)layoutSubviews;
- (void)applyLayoutAttributes:(UICollectionViewLayoutAttributes * _Nonnull)layoutAttributes;
@end


/// A custom <code>UIView</code> subclass used by <code>PagingViewController</code>,
/// responsible for setting up the view hierarchy and its layout
/// constraints.
/// If you need additional customization, like changing the
/// constraints, you can subclass <code>PagingView</code> and override
/// <code>loadView:</code> in <code>PagingViewController</code> to use your subclass.
SWIFT_CLASS("_TtC9Parchment10PagingView")
@interface PagingView : UIView
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end







#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
